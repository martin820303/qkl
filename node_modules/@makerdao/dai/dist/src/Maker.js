"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _DefaultServiceProvider = _interopRequireWildcard(require("./config/DefaultServiceProvider"));

var _ConfigFactory = _interopRequireDefault(require("./config/ConfigFactory"));

var _mergeWith = _interopRequireDefault(require("lodash/mergeWith"));

var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));

var _uniq = _interopRequireDefault(require("lodash/uniq"));

var _has = _interopRequireDefault(require("lodash/has"));

var _assert = _interopRequireDefault(require("assert"));

function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// a plugin must be either an object with at least one of these keys defined, or
// a single function, which will be treated as the value for `afterCreate`.
var PLUGIN_KEYS = ['beforeCreate', 'afterCreate', 'addConfig'];
/**
 * do not call `new Maker()` directly; use `Maker.create` instead
 */

var Maker = /*#__PURE__*/function () {
  function Maker(preset) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2["default"])(this, Maker);
    var _options$plugins = options.plugins,
        plugins = _options$plugins === void 0 ? [] : _options$plugins,
        otherOptions = (0, _objectWithoutProperties2["default"])(options, ["plugins"]);

    var _iterator = _createForOfIteratorHelper(plugins),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
            plugin = _step$value[0],
            pluginOptions = _step$value[1];

        if (plugin.addConfig) {
          mergeOptions(otherOptions, plugin.addConfig(otherOptions, pluginOptions));
        }
      } // This ensures user supplied config options always take priority

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    if (plugins && userOptions) mergeOptions(otherOptions, userOptions);

    var config = _ConfigFactory["default"].create(preset, otherOptions, _DefaultServiceProvider.resolver);

    this._container = new _DefaultServiceProvider["default"](config).buildContainer();

    var _iterator2 = _createForOfIteratorHelper(plugins),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = (0, _slicedToArray2["default"])(_step2.value, 2),
            _plugin = _step2$value[0],
            _pluginOptions = _step2$value[1];

        if (_plugin.afterCreate) _plugin.afterCreate(this, config, _pluginOptions);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    if (otherOptions.autoAuthenticate !== false) this.authenticate();
    delegateToServices(this, {
      accounts: ['addAccount', 'currentAccount', 'currentAddress', 'listAccounts', 'useAccount', 'useAccountWithAddress'],
      cdp: ['getCdp', 'openCdp', 'getCdpIds'],
      event: ['on'],
      proxy: ['currentProxy'],
      token: ['getToken'],
      multicall: ['watch', 'latest']
    });
  }

  (0, _createClass2["default"])(Maker, [{
    key: "authenticate",
    value: function authenticate() {
      if (!this._authenticatedPromise) {
        this._authenticatedPromise = this._container.authenticate();
      }

      return this._authenticatedPromise;
    } // skipAuthCheck should only be set if you're sure you don't need the service
    // to be initialized yet, e.g. when setting up a plugin

  }, {
    key: "service",
    value: function service(_service) {
      var skipAuthCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var skipAuthCheckForServices = ['event'];

      if (!skipAuthCheck && !this._container.isAuthenticated && !skipAuthCheckForServices.includes(_service)) {
        throw new Error("Can't use service ".concat(_service, " before authenticate() has finished."));
      }

      return this._container.service(_service);
    }
  }]);
  return Maker;
}();

exports["default"] = Maker;

function delegateToServices(maker, services) {
  var _loop = function _loop(serviceName) {
    var _iterator3 = _createForOfIteratorHelper(services[serviceName]),
        _step3;

    try {
      var _loop2 = function _loop2() {
        var methodName = _step3.value;

        if (serviceName === 'cdp') {
          maker[methodName] = function () {
            throw new Error("\"".concat(methodName, "\" is no longer available here. Add @makerdao/dai-plugin-scd, then use maker.service('cdp').").concat(methodName));
          };
        } else {
          maker[methodName] = function () {
            var _maker$service;

            return (_maker$service = maker.service(serviceName))[methodName].apply(_maker$service, arguments);
          };
        }
      };

      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        _loop2();
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  };

  for (var serviceName in services) {
    _loop(serviceName);
  }
}

function mergeOptions(object, source) {
  return (0, _mergeWith["default"])(object, source, function (objValue, srcValue, key) {
    if (Array.isArray(objValue) && key === 'abi') return (0, _uniq["default"])(objValue);
    if (Array.isArray(objValue) && key !== 'abi') return (0, _uniq["default"])(objValue.concat(srcValue)); // when this function returns undefined, mergeWith falls back to the
    // default merging behavior.
    // https://devdocs.io/lodash~4/index#mergeWith
  });
}

Maker.create = /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
  var _len,
      args,
      _key,
      preset,
      _args$,
      options,
      plugins,
      otherOptions,
      userOptions,
      _iterator4,
      _step4,
      _step4$value,
      p,
      popts,
      maker,
      _args = arguments;

  return _regenerator["default"].wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = _args[_key];
          }

          preset = args[0], _args$ = args[1], options = _args$ === void 0 ? {} : _args$;
          plugins = options.plugins, otherOptions = (0, _objectWithoutProperties2["default"])(options, ["plugins"]); // Preserve the user supplied options to apply after plugins are executed.

          userOptions = (0, _cloneDeep["default"])(otherOptions);

          if (!plugins) {
            _context.next = 28;
            break;
          }

          options.plugins = standardizePluginConfig(plugins);
          _iterator4 = _createForOfIteratorHelper(options.plugins);
          _context.prev = 7;

          _iterator4.s();

        case 9:
          if ((_step4 = _iterator4.n()).done) {
            _context.next = 20;
            break;
          }

          _step4$value = (0, _slicedToArray2["default"])(_step4.value, 2), p = _step4$value[0], popts = _step4$value[1];

          if (!p.beforeCreate) {
            _context.next = 18;
            break;
          }

          _context.t0 = Object;
          _context.t1 = options;
          _context.next = 16;
          return p.beforeCreate(popts);

        case 16:
          _context.t2 = _context.sent;

          _context.t0.assign.call(_context.t0, _context.t1, _context.t2);

        case 18:
          _context.next = 9;
          break;

        case 20:
          _context.next = 25;
          break;

        case 22:
          _context.prev = 22;
          _context.t3 = _context["catch"](7);

          _iterator4.e(_context.t3);

        case 25:
          _context.prev = 25;

          _iterator4.f();

          return _context.finish(25);

        case 28:
          maker = new Maker(preset, options, userOptions);

          if (!(options.autoAuthenticate !== false)) {
            _context.next = 32;
            break;
          }

          _context.next = 32;
          return maker.authenticate();

        case 32:
          return _context.abrupt("return", maker);

        case 33:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, null, [[7, 22, 25, 28]]);
}));

var standardizePluginConfig = function standardizePluginConfig(plugins) {
  return plugins.map(function (x, i) {
    var _ref2 = Array.isArray(x) ? x : [x, {}],
        _ref3 = (0, _slicedToArray2["default"])(_ref2, 2),
        plugin = _ref3[0],
        pluginOptions = _ref3[1];

    if (typeof plugin === 'function') plugin = {
      afterCreate: plugin
    };
    (0, _assert["default"])(PLUGIN_KEYS.some(function (x) {
      return (0, _has["default"])(plugin, x);
    }), "plugins[".concat(i, "] does not seem to be a plugin"));
    return [plugin, pluginOptions];
  });
};