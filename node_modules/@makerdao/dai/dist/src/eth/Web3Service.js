"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _servicesCore = require("@makerdao/services-core");

var _utils = require("../utils");

var _Web3ServiceList = _interopRequireDefault(require("../utils/Web3ServiceList"));

var _web = _interopRequireDefault(require("web3"));

var _ShimEthersSigner = _interopRequireDefault(require("./web3/ShimEthersSigner"));

var _last = _interopRequireDefault(require("lodash/last"));

var _assert = _interopRequireDefault(require("assert"));

var _debug = _interopRequireDefault(require("debug"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var log = (0, _debug["default"])('dai:Web3Service');

var Web3Service = /*#__PURE__*/function (_PrivateService) {
  (0, _inherits2["default"])(Web3Service, _PrivateService);

  var _super = _createSuper(Web3Service);

  function Web3Service() {
    var _this;

    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'web3';
    (0, _classCallCheck2["default"])(this, Web3Service);
    _this = _super.call(this, name, ['accounts', 'timer', 'cache', 'event']);
    _this._blockListeners = {};
    _this._info = {};

    _Web3ServiceList["default"].push((0, _assertThisInitialized2["default"])(_this));

    return _this;
  }

  (0, _createClass2["default"])(Web3Service, [{
    key: "currentAddress",
    value: function currentAddress() {
      return this.get('accounts').currentAddress();
    }
  }, {
    key: "getEthersSigner",
    value: function getEthersSigner() {
      if (!this._ethersSigner) this._ethersSigner = (0, _ShimEthersSigner["default"])(this);
      return this._ethersSigner;
    }
  }, {
    key: "web3Provider",
    value: function web3Provider() {
      return this._web3.currentProvider;
    }
  }, {
    key: "transactionSettings",
    value: function transactionSettings() {
      return this._transactionSettings;
    }
  }, {
    key: "confirmedBlockCount",
    value: function confirmedBlockCount() {
      return this._confirmedBlockCount;
    }
  }, {
    key: "web3Contract",
    value: function web3Contract(abi, address) {
      return new this._web3.eth.Contract(abi, address);
    }
  }, {
    key: "initialize",
    value: function initialize(settings) {
      var _this2 = this;

      log('initializing...');
      this._defaultEmitter = this.get('event');
      this._web3 = new _web["default"]();

      this._web3.setProvider(this.get('accounts').getProvider());

      Object.assign(this, ['estimateGas', 'getAccounts', 'getBalance', 'getBlock', 'getPastLogs', 'getStorageAt', 'getTransaction', 'getTransactionReceipt', 'subscribe'].reduce(function (acc, method) {
        acc[method] = function () {
          var _this2$_web3$eth;

          return (_this2$_web3$eth = _this2._web3.eth)[method].apply(_this2$_web3$eth, arguments);
        };

        return acc;
      }, {}));
      this.eth = new Proxy(this, {
        get: function get(target, key) {
          if (typeof key === 'string') console.warn("use .".concat(key, " instead of .eth.").concat(key));
          return target[key];
        }
      });
      this.manager().onDisconnected(function () {
        return _this2._stopListeningForNewBlocks();
      });

      this._defaultEmitter.emit('web3/INITIALIZED', {
        provider: settings.provider
      });

      this._transactionSettings = settings.transactionSettings;
      this._confirmedBlockCount = settings.confirmedBlockCount || 5;
      this._pollingInterval = settings.pollingInterval || 4000;
    }
  }, {
    key: "connect",
    value: function () {
      var _connect = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                log('connecting...');
                _context.t0 = parseInt;
                _context.next = 4;
                return (0, _utils.promisify)(this._web3.eth.net.getId)();

              case 4:
                _context.t1 = _context.sent;
                this._networkId = (0, _context.t0)(_context.t1);
                _context.next = 8;
                return this._web3.eth.getBlockNumber();

              case 8:
                this._currentBlock = _context.sent;

                this._updateBlockNumber(this._currentBlock);

                this._listenForNewBlocks();

                this.onNewBlock(this.get('event').ping);

                this._defaultEmitter.emit('web3/CONNECTED', _objectSpread({}, this._info));

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function connect() {
        return _connect.apply(this, arguments);
      }

      return connect;
    }()
  }, {
    key: "authenticate",
    value: function () {
      var _authenticate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                log('authenticating...');

                this._defaultEmitter.emit('web3/AUTHENTICATED', {
                  account: this.currentAddress()
                });

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function authenticate() {
        return _authenticate.apply(this, arguments);
      }

      return authenticate;
    }()
    /*
      sendTransaction in web3 1.0 behaves differently from its counterpart in
      0.2x.x. it doesn't resolve until the transaction has a receipt, and throws an
      error if the receipt indicates that the transaction was reverted.
      the setup below emulates the old behavior, because TransactionObject still
      expects it. if there is an error due to the transaction being reverted, it
      will be ignored, because the promise will have already resolved.
       this can (and should) be refactored when we drop support for HTTP providers.
       https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethsendtransaction
      https://web3js.readthedocs.io/en/1.0/web3-eth.html#sendtransaction
    */

  }, {
    key: "sendTransaction",
    value: function sendTransaction() {
      var _this3 = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return new Promise(function (resolve, reject) {
        var _this3$_web3$eth;

        (_this3$_web3$eth = _this3._web3.eth).sendTransaction.apply(_this3$_web3$eth, args).on('transactionHash', resolve).on('error', reject);
      });
    }
  }, {
    key: "networkId",
    value: function networkId() {
      console.warn('.networkId() is deprecated; use .network instead');
      return this.network;
    }
  }, {
    key: "blockNumber",
    value: function blockNumber() {
      return this._currentBlock;
    }
  }, {
    key: "onNewBlock",
    value: function onNewBlock(callback) {
      if (!this._blockListeners['*']) {
        this._blockListeners['*'] = [];
      }

      this._blockListeners['*'].push(callback);
    }
  }, {
    key: "waitForBlockNumber",
    value: function () {
      var _waitForBlockNumber = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(blockNumber) {
        var _this4 = this;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(blockNumber < this._currentBlock)) {
                  _context3.next = 3;
                  break;
                }

                console.error('Attempted to wait for past block ' + blockNumber);
                return _context3.abrupt("return");

              case 3:
                if (!(blockNumber === this._currentBlock)) {
                  _context3.next = 5;
                  break;
                }

                return _context3.abrupt("return", Promise.resolve(blockNumber));

              case 5:
                if (!this._blockListeners[blockNumber]) {
                  this._blockListeners[blockNumber] = [];
                }

                return _context3.abrupt("return", new Promise(function (resolve) {
                  _this4._blockListeners[blockNumber].push(resolve);
                }));

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function waitForBlockNumber(_x) {
        return _waitForBlockNumber.apply(this, arguments);
      }

      return waitForBlockNumber;
    }()
  }, {
    key: "_listenForNewBlocks",
    value: function _listenForNewBlocks() {
      var _this5 = this;

      if (this.networkName !== 'test') {
        log('Using newBlockHeaders subscription for block detection');
        this._newBlocksSubscription = this.subscribe('newBlockHeaders').on('data', function (_ref) {
          var blockNumber = _ref.number;
          if (!_this5._currentBlock) _this5._currentBlock = blockNumber - 1;

          for (var i = _this5._currentBlock + 1; i <= blockNumber; i++) {
            _this5._updateBlockNumber(i);
          }
        });
      } else {
        log('Using manual getBlockNumber polling for block detection');

        var updateBlocks = /*#__PURE__*/function () {
          var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
            var blockNumber, i;
            return _regenerator["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return _this5._web3.eth.getBlockNumber();

                  case 2:
                    blockNumber = _context4.sent;
                    if (!_this5._currentBlock) _this5._currentBlock = blockNumber - 1;

                    for (i = _this5._currentBlock + 1; i <= blockNumber; i++) {
                      _this5._updateBlockNumber(i);
                    }

                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));

          return function updateBlocks() {
            return _ref2.apply(this, arguments);
          };
        }();

        this._updateBlocksInterval = setInterval(updateBlocks, this._pollingInterval);
      }
    }
  }, {
    key: "_updateBlockNumber",
    value: function _updateBlockNumber(blockNumber) {
      log("Latest block: ".concat(blockNumber));
      this._currentBlock = blockNumber;

      if (this._blockListeners[blockNumber]) {
        this._blockListeners[blockNumber].forEach(function (c) {
          return c(blockNumber);
        });

        this._blockListeners[blockNumber] = undefined;
      }

      if (this._blockListeners['*']) {
        this._blockListeners['*'].forEach(function (c) {
          return c(blockNumber);
        });
      }
    }
  }, {
    key: "_stopListeningForNewBlocks",
    value: function _stopListeningForNewBlocks() {
      if (this._newBlocksSubscription) {
        this._newBlocksSubscription.unsubscribe(function (err) {
          if (err) throw err;
        });
      } else if (this._updateBlocksInterval) {
        clearInterval(this._updateBlocksInterval);
      }
    }
  }, {
    key: "network",
    get: function get() {
      (0, _assert["default"])(this._networkId, 'Cannot resolve network ID. Are you connected?');
      return this._networkId;
    }
  }, {
    key: "networkName",
    get: function get() {
      return (0, _utils.getNetworkName)(this.network);
    }
  }, {
    key: "rpcUrl",
    get: function get() {
      var provider = (0, _last["default"])(this._web3.currentProvider._providers);
      return provider.rpcUrl || provider._url || null;
    }
  }]);
  return Web3Service;
}(_servicesCore.PrivateService);

exports["default"] = Web3Service;