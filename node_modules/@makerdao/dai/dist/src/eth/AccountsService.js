"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _servicesCore = require("@makerdao/services-core");

var _map = _interopRequireDefault(require("lodash/fp/map"));

var _omit = _interopRequireDefault(require("lodash/fp/omit"));

var _pick = _interopRequireDefault(require("lodash/fp/pick"));

var _invariant = _interopRequireDefault(require("invariant"));

var _factories = require("./accounts/factories");

var _setup = require("./accounts/setup");

var _constants = require("../utils/constants");

var _assert = _interopRequireDefault(require("assert"));

var _debug = _interopRequireDefault(require("debug"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var log = (0, _debug["default"])('dai:AccountsService');
var sanitizeAccount = (0, _pick["default"])(['name', 'type', 'address']);

var AccountsService = /*#__PURE__*/function (_PublicService) {
  (0, _inherits2["default"])(AccountsService, _PublicService);

  var _super = _createSuper(AccountsService);

  function AccountsService() {
    var _this;

    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'accounts';
    (0, _classCallCheck2["default"])(this, AccountsService);
    _this = _super.call(this, name, ['event']);
    _this._accounts = {};
    _this._accountFactories = {
      privateKey: _factories.privateKeyAccountFactory,
      provider: _factories.providerAccountFactory,
      browser: _factories.browserProviderAccountFactory
    };
    return _this;
  }

  (0, _createClass2["default"])(AccountsService, [{
    key: "initialize",
    value: function () {
      var _initialize = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var settings,
            result,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                settings = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
                this._settings = (0, _omit["default"])('web3', settings);
                _context.next = 4;
                return (0, _setup.setupEngine)(settings);

              case 4:
                result = _context.sent;
                this._engine = result.engine;
                this._provider = result.provider;

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function initialize() {
        return _initialize.apply(this, arguments);
      }

      return initialize;
    }()
  }, {
    key: "connect",
    value: function () {
      var _connect = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var accountNames, _i, _accountNames, name;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                accountNames = Object.keys(this._settings);
                _i = 0, _accountNames = accountNames;

              case 2:
                if (!(_i < _accountNames.length)) {
                  _context2.next = 9;
                  break;
                }

                name = _accountNames[_i];
                _context2.next = 6;
                return this.addAccount(name, this._settings[name]);

              case 6:
                _i++;
                _context2.next = 2;
                break;

              case 9:
                if (!(accountNames.length === 0)) {
                  _context2.next = 12;
                  break;
                }

                _context2.next = 12;
                return this.addAccount('default', {
                  type: _constants.AccountType.PROVIDER
                });

              case 12:
                this._engine.start();

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function connect() {
        return _connect.apply(this, arguments);
      }

      return connect;
    }()
  }, {
    key: "getProvider",
    value: function getProvider() {
      return this._engine;
    }
  }, {
    key: "addAccountType",
    value: function addAccountType(type, factory) {
      (0, _invariant["default"])(!this._accountFactories[type], "Account type \"".concat(type, "\" is already defined"));
      this._accountFactories[type] = factory;
    }
  }, {
    key: "addAccount",
    value: function () {
      var _addAccount = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(name) {
        var options,
            _options,
            type,
            autoSwitch,
            otherSettings,
            factory,
            accountData,
            account,
            _args3 = arguments;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};

                if (name && typeof name !== 'string') {
                  options = name;
                  name = null;
                }

                _options = options, type = _options.type, autoSwitch = _options.autoSwitch, otherSettings = (0, _objectWithoutProperties2["default"])(_options, ["type", "autoSwitch"]);
                (0, _invariant["default"])(this._engine, 'engine must be set up before adding an account');

                if (!(name && this._accounts[name])) {
                  _context3.next = 6;
                  break;
                }

                throw new Error('An account with this name already exists.');

              case 6:
                factory = this._accountFactories[type];
                (0, _invariant["default"])(factory, "no factory for type \"".concat(type, "\""));
                _context3.next = 10;
                return factory(otherSettings, this._provider);

              case 10:
                accountData = _context3.sent;

                if (accountData.address) {
                  _context3.next = 14;
                  break;
                }

                log("Not adding account \"".concat(name, "\" (no address found)"));
                return _context3.abrupt("return");

              case 14:
                accountData.address = accountData.address.toLowerCase();

                if (!this._getAccountWithAddress(accountData.address)) {
                  _context3.next = 17;
                  break;
                }

                throw new Error('An account with this address already exists.');

              case 17:
                if (!name) name = accountData.address;
                account = _objectSpread({
                  name: name,
                  type: type,
                  autoSwitch: autoSwitch || false
                }, accountData);
                this._accounts[name] = account;

                if (!this._currentAccount || name === 'default') {
                  this.useAccount(name);
                }

                if (this.hasAccount()) {
                  this.get('event').emit('accounts/ADD', {
                    account: sanitizeAccount(account)
                  });
                }

                return _context3.abrupt("return", account);

              case 23:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function addAccount(_x) {
        return _addAccount.apply(this, arguments);
      }

      return addAccount;
    }()
  }, {
    key: "listAccounts",
    value: function listAccounts() {
      return (0, _map["default"])(sanitizeAccount, this._accounts);
    }
  }, {
    key: "useAccount",
    value: function useAccount(name) {
      var account = this._accounts[name];
      (0, _invariant["default"])(account, "No account found with name \"".concat(name, "\"."));
      if (this._autoSwitchCheckHandle) clearInterval(this._autoSwitchCheckHandle);

      if (account.type === _constants.AccountType.BROWSER) {
        (0, _assert["default"])(isAddressSelected(account.address), 'cannot use a browser account that is not currently selected'); // detect account change and automatically switch active account if
        // autoSwitch flag set (useful if using a browser wallet like MetaMask)
        // see: https://github.com/MetaMask/faq/blob/master/DEVELOPERS.md#ear-listening-for-selected-account-changes

        if (account.autoSwitch) {
          this._autoSwitchCheckHandle = setInterval(this._autoSwitchCheckAccountChange(account.address), 500);
        }
      }

      if (this._currentAccount) {
        this._engine.stop();

        this._engine.removeProvider(this.currentWallet());
      }

      this._currentAccount = name; // add the provider at index 0 so that it takes precedence over RpcSource

      this._engine.addProvider(this.currentWallet(), 0);

      this._engine.start();

      if (this.hasAccount()) {
        this.get('event').emit('accounts/CHANGE', {
          account: this.currentAccount()
        });
      }
    }
  }, {
    key: "_autoSwitchCheckAccountChange",
    value: function _autoSwitchCheckAccountChange(addr) {
      var _this2 = this;

      return /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        var activeBrowserAddress;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                activeBrowserAddress = getSelectedAddress().toLowerCase();

                if (!(activeBrowserAddress !== addr)) {
                  _context4.next = 6;
                  break;
                }

                if (_this2._getAccountWithAddress(activeBrowserAddress)) {
                  _context4.next = 5;
                  break;
                }

                _context4.next = 5;
                return _this2.addAccount({
                  type: _constants.AccountType.BROWSER,
                  autoSwitch: true
                });

              case 5:
                _this2.useAccountWithAddress(activeBrowserAddress);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
    }
  }, {
    key: "_getAccountWithAddress",
    value: function _getAccountWithAddress(addr) {
      var accountObjects = Object.values(this._accounts);
      return accountObjects.find(function (e) {
        return e.address.toUpperCase() === addr.toUpperCase();
      });
    }
  }, {
    key: "useAccountWithAddress",
    value: function useAccountWithAddress(addr) {
      var account = this._getAccountWithAddress(addr);

      if (!account) throw new Error("No account found with address ".concat(addr));
      this.useAccount(account.name);
    }
  }, {
    key: "hasAccount",
    value: function hasAccount() {
      return !!this._currentAccount;
    }
  }, {
    key: "hasNonProviderAccount",
    value: function hasNonProviderAccount() {
      return this.hasAccount() && this.currentAccount().type != _constants.AccountType.PROVIDER;
    } // we intentionally omit subprovider (implementation detail) and privateKey
    // (sensitive info).

  }, {
    key: "currentAccount",
    value: function currentAccount() {
      (0, _invariant["default"])(this.hasAccount(), 'No account is set up.');
      return sanitizeAccount(this._accounts[this._currentAccount]);
    }
  }, {
    key: "currentAddress",
    value: function currentAddress() {
      (0, _invariant["default"])(this.hasAccount(), 'No account is set up.');
      return this._accounts[this._currentAccount].address;
    }
  }, {
    key: "currentWallet",
    value: function currentWallet() {
      return this._accounts[this._currentAccount].subprovider;
    }
  }]);
  return AccountsService;
}(_servicesCore.PublicService);

exports["default"] = AccountsService;

function getSelectedAddress() {
  return typeof window.ethereum !== 'undefined' ? window.ethereum.selectedAddress : window.web3.eth.defaultAccount;
}

function isAddressSelected(address) {
  // if using browser/MetaMask, we must use the currently selected account;
  // however, it can be blank the first time the user connects their account.
  var selectedAddress = getSelectedAddress();
  return !selectedAddress || selectedAddress.toLowerCase() === address;
}