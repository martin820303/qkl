"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _servicesCore = require("@makerdao/services-core");

var _TransactionObject = _interopRequireDefault(require("./TransactionObject"));

var _utils = require("../utils");

var _each = _interopRequireDefault(require("lodash/each"));

var _has = _interopRequireDefault(require("lodash/has"));

var _util = require("util");

var _debug = _interopRequireDefault(require("debug"));

function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var log = (0, _debug["default"])('dai:TransactionManager');

var TransactionManager = /*#__PURE__*/function (_PublicService) {
  (0, _inherits2["default"])(TransactionManager, _PublicService);

  var _super = _createSuper(TransactionManager);

  function TransactionManager() {
    var _this;

    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transactionManager';
    (0, _classCallCheck2["default"])(this, TransactionManager);
    _this = _super.call(this, name, ['web3', 'nonce', 'proxy', 'gas']);
    _this._newTxListeners = [];
    _this._tracker = new Tracker();
    return _this;
  } // this method must not be async


  (0, _createClass2["default"])(TransactionManager, [{
    key: "sendContractCall",
    value: function sendContractCall(contract, method, args, name) {
      var _this2 = this;

      log("sendContractCall: ".concat(name, ".").concat(method, " ").concat((0, _util.inspect)(args)));
      if (!args) args = [];
      var options,
          promise,
          businessObject,
          metadata = {
        contract: name,
        method: method.replace(/\(.*\)$/g, ''),
        args: args
      },
          lastArg = args[args.length - 1];

      if ((0, _typeof2["default"])(lastArg) === 'object' && lastArg.constructor === Object) {
        options = lastArg;
        args = args.slice(0, args.length - 1); // append additional metadata to the default values.

        if (options.metadata) {
          metadata = _objectSpread(_objectSpread({}, metadata), options.metadata);
          delete options.metadata;
        }

        if ((0, _has["default"])(options, 'promise')) {
          if (options.promise) promise = options.promise;
          delete options.promise;
        }

        if (options.businessObject) {
          businessObject = options.businessObject;
          delete options.businessObject;
        } // some subproviders require a value key included with the Tx


        if (!(0, _has["default"])(options, 'value')) {
          options.value = 0;
        }
      } else {
        options = {};
      } // for promise tracking to work, we must return to the caller the result of
      // _createTransactionObject, because that promise is the one stored for
      // lookup to attach lifecycle hooks.


      return this._createTransactionObject((0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var txOptions;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this2._buildTransactionOptions(options, contract, method, args);

              case 2:
                txOptions = _context.sent;
                return _context.abrupt("return", _this2._execute(contract, method, args, txOptions));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))(), {
        businessObject: businessObject,
        metadata: metadata,
        promise: promise
      });
    } // this method must not be async

  }, {
    key: "sendTransaction",
    value: function sendTransaction(options, metadata) {
      var _this3 = this;

      return this._createTransactionObject((0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var txOptions;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this3._buildTransactionOptions(options);

              case 2:
                txOptions = _context2.sent;
                return _context2.abrupt("return", _this3.get('web3').sendTransaction(txOptions));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))(), metadata);
    }
  }, {
    key: "onNewTransaction",
    value: function onNewTransaction(cb) {
      this._newTxListeners.push(cb);
    }
  }, {
    key: "onTransactionUpdate",
    value: function onTransactionUpdate(cb) {
      var _this4 = this;

      this._tracker._globalListeners.push(cb);

      return {
        unsub: function unsub() {
          var idx = _this4._tracker._globalListeners.indexOf(cb);

          if (idx !== -1) _this4._tracker._globalListeners.splice(idx, 1);
        }
      };
    }
  }, {
    key: "getTransaction",
    value: function getTransaction(promise, label) {
      return this._tracker.get((0, _utils.uniqueId)(promise), label);
    }
  }, {
    key: "confirm",
    value: function () {
      var _confirm = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(promise, count) {
        var txs;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return promise;

              case 2:
                txs = this._tracker.getAll((0, _utils.uniqueId)(promise));
                return _context3.abrupt("return", Promise.all(txs.map(function (tx) {
                  return tx.confirm(count);
                })));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function confirm(_x, _x2) {
        return _confirm.apply(this, arguments);
      }

      return confirm;
    }()
  }, {
    key: "isMined",
    value: function isMined(promise) {
      return this._tracker.get((0, _utils.uniqueId)(promise)).isMined();
    }
  }, {
    key: "listen",
    value: function listen(promise, handlers) {
      if (typeof handlers === 'function') {
        this._tracker.listen((0, _utils.uniqueId)(promise), {
          pending: function pending(tx) {
            return handlers(tx, 'pending');
          },
          mined: function mined(tx) {
            return handlers(tx, 'mined');
          },
          confirmed: function confirmed(tx) {
            return handlers(tx, 'confirmed');
          },
          error: function error(tx, err) {
            return handlers(tx, 'error', err);
          }
        });
      } else {
        this._tracker.listen((0, _utils.uniqueId)(promise), handlers);
      }
    } // if options.dsProxy is set, execute this contract method through the
    // proxy contract at that address.

  }, {
    key: "_execute",
    value: function _execute(contract, method, args, options) {
      if (!options.dsProxy) return contract[method].apply(contract, (0, _toConsumableArray2["default"])(args).concat([options]));
      var address;

      if (typeof options.dsProxy === 'string') {
        address = options.dsProxy;
      }

      delete options.dsProxy;
      return this.get('proxy').execute(contract, method, args, options, address);
    }
  }, {
    key: "_createTransactionObject",
    value: function _createTransactionObject(tx) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          businessObject = _ref3.businessObject,
          metadata = _ref3.metadata,
          promise = _ref3.promise;

      var txo = new _TransactionObject["default"](tx, this, {
        businessObject: businessObject,
        metadata: metadata
      });

      this._newTxListeners.forEach(function (cb) {
        return cb(txo);
      });

      var minePromise = txo.mine(); // we store the transaction object under the unique id of its own mine
      // promise, so that it can be looked up when calling a contract function
      // directly from a service method, e.g. WethToken.deposit.

      this._tracker.store((0, _utils.uniqueId)(minePromise), txo); // if the `promise` object is defined in the options argument, we also store
      // the transaction object under that promise's id, so that it can be looked
      // up when calling a contract function indirectly via two or more nested
      // service method calls, e.g.
      // EthereumCdpService.lockEth -> WethToken.deposit.


      if (promise) this._tracker.store((0, _utils.uniqueId)(promise), txo, {
        globalTxStateUpdates: false
      });
      return minePromise;
    }
  }, {
    key: "_buildTransactionOptions",
    value: function () {
      var _buildTransactionOptions2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(options, contract, method, args) {
        var txSpeed;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(contract && !options.gasLimit)) {
                  _context4.next = 4;
                  break;
                }

                _context4.next = 3;
                return this._getGasLimit(options, contract, method, args);

              case 3:
                options.gasLimit = _context4.sent;

              case 4:
                if (this.get('gas').disablePrice) {
                  _context4.next = 9;
                  break;
                }

                txSpeed = options.transactionSpeed;
                _context4.next = 8;
                return this.get('gas').getGasPrice(txSpeed);

              case 8:
                options.gasPrice = _context4.sent;

              case 9:
                _context4.t0 = _objectSpread;
                _context4.t1 = _objectSpread(_objectSpread({}, options), this.get('web3').transactionSettings());
                _context4.t2 = {};
                _context4.next = 14;
                return this.get('nonce').getNonce();

              case 14:
                _context4.t3 = _context4.sent;
                _context4.t4 = {
                  nonce: _context4.t3
                };
                return _context4.abrupt("return", (0, _context4.t0)(_context4.t1, _context4.t2, _context4.t4));

              case 17:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _buildTransactionOptions(_x3, _x4, _x5, _x6) {
        return _buildTransactionOptions2.apply(this, arguments);
      }

      return _buildTransactionOptions;
    }()
  }, {
    key: "_getGasLimit",
    value: function () {
      var _getGasLimit2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(options, contract, method, args) {
        var _contract$interface$f;

        var transaction, data, proxyAddress, proxy;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                transaction = {};
                data = (_contract$interface$f = contract["interface"].functions)[method].apply(_contract$interface$f, (0, _toConsumableArray2["default"])(args)).data;

                if (!options.dsProxy) {
                  _context5.next = 8;
                  break;
                }

                _context5.next = 5;
                return this.get('proxy').currentProxy();

              case 5:
                proxyAddress = _context5.sent;
                proxy = this.get('proxy').getUnwrappedProxyContract(proxyAddress);
                data = proxy["interface"].functions['execute'](contract.address, data).data;

              case 8:
                if (options.value) {
                  transaction.value = options.value;
                }

                transaction = _objectSpread({
                  from: this.get('web3').currentAddress(),
                  to: options.dsProxy ? proxyAddress : contract.address,
                  data: data
                }, transaction);
                return _context5.abrupt("return", this.get('gas').estimateGasLimit(transaction));

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _getGasLimit(_x7, _x8, _x9, _x10) {
        return _getGasLimit2.apply(this, arguments);
      }

      return _getGasLimit;
    }()
  }]);
  return TransactionManager;
}(_servicesCore.PublicService);

exports["default"] = TransactionManager;

var Tracker = /*#__PURE__*/function () {
  function Tracker() {
    (0, _classCallCheck2["default"])(this, Tracker);
    this._listeners = {};
    this._globalListeners = [];
    this._transactions = {};
  }

  (0, _createClass2["default"])(Tracker, [{
    key: "store",
    value: function store(key, tx) {
      var _this5 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        globalTxStateUpdates: true
      };

      this._init(key);

      this._transactions[key].push(tx);

      var _iterator = _createForOfIteratorHelper(this.constructor.states),
          _step;

      try {
        var _loop = function _loop() {
          var state = _step.value;
          tx.on(state, function () {
            if (options.globalTxStateUpdates) {
              _this5._globalListeners.forEach(function (cb) {
                return tx.error ? cb(tx, state, tx.error) : cb(tx, state);
              });
            }

            _this5._listeners[key][state].forEach(function (cb) {
              return tx.error ? cb(tx, tx.error) : cb(tx);
            });
          });
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (options.globalTxStateUpdates) this._globalListeners.forEach(function (cb) {
        return cb(tx, 'initialized');
      });

      this._listeners[key].initialized.forEach(function (cb) {
        return tx.error ? cb(tx, tx.error) : cb(tx);
      });

      this.clearExpiredTransactions();
    }
  }, {
    key: "listen",
    value: function listen(key, handlers) {
      var _this6 = this;

      this._init(key);

      var _loop2 = function _loop2(_state) {
        var cb = handlers[_state];
        if (_state === 'confirmed') _state = 'finalized';

        _this6._listeners[key][_state].push(cb); // if event has already happened, call handler immediately


        _this6._transactions[key].forEach(function (tx) {
          return tx && tx.inOrPastState(_state) && (tx.error ? cb(tx, tx.error) : cb(tx));
        });

        state = _state;
      };

      for (var state in handlers) {
        _loop2(state);
      }
    }
  }, {
    key: "getAll",
    value: function getAll(key) {
      return this._transactions[key];
    }
  }, {
    key: "get",
    value: function get(key) {
      var txs = this._transactions[key];

      if (!txs || txs.length === 0) {
        throw new Error("No transactions for key ".concat(key));
      }

      if (txs.length > 1) {
        console.warn("Key ".concat(key, " matches ").concat(txs.length, " transactions; returning the first."));
      }

      return txs[0];
    }
  }, {
    key: "clearExpiredTransactions",
    value: function clearExpiredTransactions() {
      var _this7 = this;

      (0, _each["default"])(this._transactions, function (txList, key) {
        txList.forEach(function (tx) {
          var txAge = (new Date().getTime() - new Date(tx._timeStampMined).getTime()) / 60000;

          if ((tx.isError() || tx.isFinalized()) && txAge > 5) {
            var indexToRemove = _this7._transactions[key].indexOf(tx);

            _this7._transactions[key].splice(indexToRemove, 1);

            if (_this7._transactions[key].length === 0) {
              delete _this7._transactions[key];
              delete _this7._listeners[key];
            }
          }
        });
      });
    }
  }, {
    key: "_init",
    value: function _init(key) {
      if (!this._transactions[key]) this._transactions[key] = [];

      if (!this._listeners[key]) {
        this._listeners[key] = this.constructor.states.reduce(function (acc, state) {
          acc[state] = [];
          return acc;
        }, {});
      }
    }
  }]);
  return Tracker;
}();

(0, _defineProperty2["default"])(Tracker, "states", ['initialized', 'pending', 'mined', 'finalized', 'error']);