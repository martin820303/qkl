"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _servicesCore = require("@makerdao/services-core");

var _multicall = require("@makerdao/multicall");

var _debug = _interopRequireDefault(require("debug"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _get = _interopRequireDefault(require("lodash/get"));

var _set = _interopRequireDefault(require("lodash/set"));

var _find = _interopRequireDefault(require("lodash/find"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var log = (0, _debug["default"])('dai:MulticallService');
var log2 = (0, _debug["default"])('dai:MulticallService:observables');

var throwIfErrorInValues = function throwIfErrorInValues(values) {
  return values.map(function (v) {
    if (v instanceof Error) throw v;
  });
}; // prettier-ignore


var checkForErrors = function checkForErrors(values) {
  return (0, _find["default"])(values, function (v) {
    return v instanceof Error;
  }) === undefined;
};

var catchNestedErrors = function catchNestedErrors(key) {
  return function (f) {
    return (0, _operators.catchError)(function (err) {
      log2("Caught nested error in ".concat(key, ": ").concat(err));
      return (0, _rxjs.from)([new Error(err)]);
    })(f);
  };
};

var MulticallService = /*#__PURE__*/function (_PublicService) {
  (0, _inherits2["default"])(MulticallService, _PublicService);

  var _super = _createSuper(MulticallService);

  function MulticallService() {
    var _this;

    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'multicall';
    (0, _classCallCheck2["default"])(this, MulticallService);
    _this = _super.call(this, name, ['web3', 'smartContract']);
    _this._schemas = [];
    _this._schemaByObservableKey = {};
    _this._schemaInstances = {};
    _this._subjects = {};
    _this._observables = {};
    _this._watcherUpdates = null;
    _this._schemaSubscribers = {};
    _this._totalSchemaSubscribers = 0;
    _this._totalActiveSchemas = 0;
    _this._multicallResultCache = {};
    _this._addresses = {};
    _this._removeSchemaTimers = {};
    return _this;
  }

  (0, _createClass2["default"])(MulticallService, [{
    key: "initialize",
    value: function initialize() {
      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._addresses = settings.addresses || this.get('smartContract').getContractAddresses();
      this._removeSchemaDelay = settings.removeSchemaDelay || 1000;
      this._debounceTime = settings.debounceTime || 1;
      this._latestDebounceTime = settings.latestDebounceTime || 1;
      this._latestTimeout = settings.latestTimeout || 10000;
    }
  }, {
    key: "authenticate",
    value: function authenticate() {
      this._connectedAddress = this.get('web3').currentAddress();
    }
  }, {
    key: "createWatcher",
    value: function createWatcher() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$useWeb3Provider = _ref.useWeb3Provider,
          useWeb3Provider = _ref$useWeb3Provider === void 0 ? false : _ref$useWeb3Provider,
          _ref$interval = _ref.interval,
          interval = _ref$interval === void 0 ? 'block' : _ref$interval,
          rpcUrl = _ref.rpcUrl,
          config = (0, _objectWithoutProperties2["default"])(_ref, ["useWeb3Provider", "interval", "rpcUrl"]);

      var web3 = this.get('web3');
      config = _objectSpread({
        multicallAddress: this.get('smartContract').getContractAddress('MULTICALL')
      }, config);
      var onNewBlockPolling = interval === 'block';
      if (onNewBlockPolling) interval = 60000; // 1 min polling fallback safeguard

      if (useWeb3Provider) config.web3 = web3._web3;else if (!rpcUrl) {
        if (!web3.rpcUrl) new Error('Unable to get rpcUrl for multicall');
        rpcUrl = web3.rpcUrl;
      }
      this._watcher = (0, _multicall.createWatcher)([], _objectSpread(_objectSpread({}, config), {}, {
        interval: interval,
        rpcUrl: rpcUrl
      }));

      if (onNewBlockPolling) {
        log("Watcher created with poll on new block mode using ".concat(rpcUrl ? "rpcUrl: ".concat(rpcUrl) : 'web3 provider')); // prettier-ignore

        web3.onNewBlock(function (blockNumber) {
          log("Polling after new block detected (".concat(blockNumber, ")"));

          _this2._watcher.poll();
        });
      } else {
        log("Watcher created with ".concat(interval, "ms polling interval using ").concat(useWeb3Provider ? 'web3 provider' : "rpcUrl: ".concat(rpcUrl)));
      }

      this._watcher.onPoll(function (_ref2) {
        var id = _ref2.id,
            block = _ref2.latestBlockNumber;
        return log("Sending network request #".concat(id).concat(block ? " (latest block: ".concat(block, ")") : ''));
      });

      this._watcher.onNewBlock(function (block) {
        return log("Latest block: ".concat(block));
      });

      this._watcher.onError(function (err) {
        return console.error('Multicall error:', err);
      });

      return this._watcher;
    }
  }, {
    key: "tap",
    value: function tap(cb) {
      log('Watcher tapped');
      return this._watcher.tap(cb);
    }
  }, {
    key: "start",
    value: function start() {
      log('Watcher started');
      return this._watcher.start();
    }
  }, {
    key: "stop",
    value: function stop() {
      this._flushPendingSchemaRemovals();

      log('Watcher stopped');
      return this._watcher.stop();
    }
  }, {
    key: "restart",
    value: function restart() {
      this.stop();
      this.start();
    }
  }, {
    key: "schemaByObservableKey",
    value: function schemaByObservableKey(key) {
      if (!key) throw new Error('Invalid observable key');
      if (!this._schemaByObservableKey[key]) throw new Error("No registered schema definition found with observable key: ".concat(key));
      return this._schemaByObservableKey[key];
    }
  }, {
    key: "registerSchemas",
    // Register schema definitions
    value: function registerSchemas(schemas) {
      var _this3 = this;

      if ((0, _typeof2["default"])(schemas) !== 'object') throw new Error('Schemas must be object or array'); // If schemas is key/val object use key as schema key and convert to array object

      if (!Array.isArray(schemas)) schemas = Object.keys(schemas).map(function (key) {
        return _objectSpread({
          key: key
        }, schemas[key]);
      }); // prettier-ignore
      // Clone if array
      else schemas = schemas.map(function (item) {
          return _objectSpread({}, item);
        });
      schemas.forEach(function (schema) {
        if (!schema.key) throw new Error('Schema definitions must have a unique key'); // Automatically use schema key as return key if no return keys specified

        if (!schema["return"] && !schema.returns) schema.returns = [schema.key];
        if (schema["return"] && schema.returns) throw new Error('Ambiguous return definitions in schema: found both return and returns property'); // prettier-ignore

        if (schema["return"]) schema.returns = [schema["return"]];
        if (!Array.isArray(schema.returns)) throw new Error('Schema must contain return/returns property'); // Use return keys to create observable key => schema mapping
        // and normalize as array of [key, transform] arrays

        schema.returns = schema.returns.map(function (ret) {
          if (!Array.isArray(ret)) ret = [ret];
          if (_this3._schemaByObservableKey[ret[0]] !== undefined) throw new Error("Observable with key ".concat(ret[0], " already registered"));
          _this3._schemaByObservableKey[ret[0]] = schema;
          if (ret.length > 2) throw new Error('Returns array format should be [key, transform]');
          return ret;
        });
      });
      this._schemas = [].concat((0, _toConsumableArray2["default"])(this._schemas), (0, _toConsumableArray2["default"])(schemas));
      log2("Registered ".concat(schemas.length, " schemas"));
    }
  }, {
    key: "latest",
    value: function latest(key) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var obsPath = "".concat(key).concat(args.length > 0 ? '.' : '').concat(args.join('.'));
      return this._watch.apply(this, [{
        depth: 0,
        throwIfError: true
      }, key].concat(args)).pipe((0, _operators.catchError)(function (err) {
        throw new Error(err);
      }), (0, _operators.takeUntil)((0, _rxjs.timer)(this._latestTimeout)), (0, _operators.throwIfEmpty)(function () {
        return new Error("Timed out waiting for latest value of: ".concat(obsPath));
      }), (0, _operators.debounceTime)(this._latestDebounceTime), (0, _operators.take)(1)).toPromise();
    }
  }, {
    key: "watch",
    value: function watch(key) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return this._watch.apply(this, [{
        depth: 0
      }, key].concat(args));
    }
  }, {
    key: "_watch",
    value: function _watch(_ref3, key) {
      var _schemaDefinition$val,
          _this4 = this;

      var depth = _ref3.depth,
          _ref3$throwIfError = _ref3.throwIfError,
          throwIfError = _ref3$throwIfError === void 0 ? false : _ref3$throwIfError;
      // Find schema definition associated with this observable key
      var schemaDefinition = this.schemaByObservableKey(key);
      var expectedArgs = schemaDefinition.generate.length;

      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }

      if (args.length < expectedArgs) return (0, _rxjs.throwError)("Observable ".concat(key, " expects at least ").concat(expectedArgs, " argument(s)"));
      var obsPath = "".concat(key).concat(args.length > 0 ? '.' : '').concat(args.join('.')); // Validate arguments using schema args validator

      if (schemaDefinition === null || schemaDefinition === void 0 ? void 0 : (_schemaDefinition$val = schemaDefinition.validate) === null || _schemaDefinition$val === void 0 ? void 0 : _schemaDefinition$val.args) {
        var _schemaDefinition$val2;

        var validate = (_schemaDefinition$val2 = schemaDefinition.validate).args.apply(_schemaDefinition$val2, args);

        if (validate) {
          log2("Input validation failed for observable: ".concat(obsPath, " (depth: ").concat(depth, ")"));
          return (0, _rxjs.throwError)(validate);
        }
      } // Create or get existing schema instance for this instance path (schema definition + args)


      var schemaInstance = this._createSchemaInstance.apply(this, [schemaDefinition].concat(args));

      var computed = schemaInstance.computed;
      log2("watch() called for ".concat(computed ? 'computed ' : 'base ', "observable: ").concat(obsPath, " (depth: ").concat(depth, ")")); // prettier-ignore
      // Return existing observable if one already exists for this observable path (key + args)

      var existing = (0, _get["default"])(this._observables, obsPath);

      if (existing) {
        if (computed) {
          log2("Returning existing computed observable: ".concat(obsPath, " (depth: ").concat(depth, ")")); // Only debounce if call to watch() is not nested

          if (depth === 0) existing = existing.pipe((0, _operators.debounceTime)(this._debounceTime));
          if (throwIfError) existing = existing.pipe((0, _operators.tap)(throwIfErrorInValues));
          return existing.pipe( // Don't pass values to computed() if any of them are errors
          (0, _operators.filter)(checkForErrors), // Pass values to computed() on the computed observable
          (0, _operators.map)(function (result) {
            return computed.apply(void 0, (0, _toConsumableArray2["default"])(result));
          }));
        }

        log2("Returning existing base observable: ".concat(obsPath));
        return existing;
      } // Handle computed observable


      if (computed) {
        // Handle dynamically generated dependencies
        var dependencies = typeof schemaInstance.dependencies === 'function' ? schemaInstance.dependencies({
          watch: this.watch.bind(this),
          get: this.get.bind(this)
        }) : schemaInstance.dependencies;

        var recurseDependencyTree = function recurseDependencyTree(trie_) {
          var key = trie_[0];
          var trie = trie_.slice(1); // If the dependency key provided is a function, promise or array of
          // values then this dependency is providing its own custom value
          // rather than specifying an existing observable key

          if (key instanceof Promise || Array.isArray(key)) return (0, _rxjs.from)(key);
          if (typeof key === 'function') return (0, _rxjs.from)(key());
          var indexesAtLeafNodes = trie.map(function (node) {
            return !Array.isArray(node);
          });
          var allLeafNodes = indexesAtLeafNodes.every(function (node) {
            return node === true;
          });

          if (Array.isArray(trie) && trie.length === 0) {
            // When trie is an empty array, indicates that we only need to return
            // watch on the key
            return _this4._watch({
              depth: depth + 1
            }, key);
          } else if (allLeafNodes) {
            // If the trie is an array it indicates that the observable is
            // expecting arguments. These can be normal values or other
            // observables. Where an index in the trie is an array, it is
            // assumed that it is syntax for an observable argument. In the case
            // where all indexes in the trie array are normal values, we use the
            // spread operator to pass them to the returned watch fn
            return _this4._watch.apply(_this4, [{
              depth: depth + 1
            }, key].concat((0, _toConsumableArray2["default"])(trie)));
          } else {
            // When a trie array has nested observables, recursively call this fn
            // on indexes which have an array.
            return (0, _rxjs.combineLatest)(trie.map(function (node, idx) {
              return indexesAtLeafNodes[idx] ? [node] : recurseDependencyTree(node);
            })).pipe((0, _operators.flatMap)(function (result) {
              return _this4._watch.apply(_this4, [{
                depth: depth + 1
              }, key].concat((0, _toConsumableArray2["default"])(result))).pipe(catchNestedErrors(key));
            }));
          }
        };

        var dependencySubs = dependencies.map(recurseDependencyTree);

        var _observable = (0, _rxjs.combineLatest)(dependencySubs);

        log2("Created new computed observable: ".concat(obsPath, " (depth: ").concat(depth, ")"));
        (0, _set["default"])(this._observables, obsPath, _observable); // Only debounce if call to watch() is not nested

        if (depth === 0) _observable = _observable.pipe((0, _operators.debounceTime)(this._debounceTime));
        if (throwIfError) _observable = _observable.pipe((0, _operators.tap)(throwIfErrorInValues));
        return _observable.pipe( // Don't pass values to computed() if any of them are errors
        (0, _operators.filter)(checkForErrors), // Pass values to computed() on the computed observable
        (0, _operators.map)(function (result) {
          return computed.apply(void 0, (0, _toConsumableArray2["default"])(result));
        }));
      } // This is a base observable


      var id = schemaInstance.id,
          path = schemaInstance.path;
      if (this._schemaSubscribers[path] === undefined) this._schemaSubscribers[path] = 0;
      var subject = new _rxjs.ReplaySubject(1);
      (0, _set["default"])(this._subjects, obsPath, subject); // Handle initial value if cached result from multicall exists

      if (this._multicallResultCache[obsPath] !== undefined) this._handleResult(subject, obsPath, this._multicallResultCache[obsPath]); // Create base observable

      var observable = _rxjs.Observable.create(function (observer) {
        _this4._totalSchemaSubscribers++;
        log2("Observer subscribed to ".concat(id, " (").concat(_this4._schemaSubscribers[path] + 1, " subscribers)")); // If first subscriber to this schema add it to multicall

        if (++_this4._schemaSubscribers[path] === 1) _this4._addSchemaToMulticall(schemaInstance); // Subscribe to watcher updates and emit them to subjects

        if (!_this4._watcherUpdates) _this4._subscribeToWatcherUpdates(); // Subscribe this observer to the subject for this base observable

        var sub = subject.subscribe(observer); // Return the function to call when this observer unsubscribes

        return function () {
          _this4._totalSchemaSubscribers--; // If last unsubscriber from this schema remove it from multicall

          if (--_this4._schemaSubscribers[path] === 0) _this4._removeSchemaFromMulticall(schemaInstance.id); // Unsubscribe this observer from the subject for this base observable

          sub.unsubscribe();
          log2("Observer unsubscribed from ".concat(id, " (").concat(_this4._schemaSubscribers[path], " subscribers)")); // prettier-ignore
        };
      });

      log2("Created new base observable: ".concat(obsPath));
      (0, _set["default"])(this._observables, obsPath, observable);
      return observable;
    }
  }, {
    key: "_createSchemaInstance",
    value: function _createSchemaInstance(schemaDefinition) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      var path = args.join('.');
      var instancePath = "".concat(schemaDefinition.key).concat(path ? '.' : '').concat(path); // Return existing schema if found for this instance path (schema key + args)

      if (this._schemaInstances[instancePath]) return this._schemaInstances[instancePath]; // Generate schema instance

      var schemaInstance = schemaDefinition.generate.apply(schemaDefinition, args);
      this._schemaInstances[instancePath] = schemaInstance;
      schemaInstance.args = [].concat(args); // Auto generate some fields if this is a base schema

      if (!schemaInstance.computed) {
        var returns = schemaInstance.returns,
            _schemaInstance$trans = schemaInstance.transforms,
            transforms = _schemaInstance$trans === void 0 ? {} : _schemaInstance$trans;
        schemaInstance.path = instancePath; // Auto generate return keys for schema instance if not provided by generate()

        if (!returns) {
          schemaInstance.returns = schemaDefinition.returns.map(function (ret) {
            var key = ret[0];
            var fullPath = "".concat(key).concat(path ? '.' : '').concat(path);
            return transforms[key] ? [fullPath, transforms[key]] // Use transform mapping in generated schema instance if available
            : ret.length == 2 ? [fullPath, ret[1]] : [fullPath];
          });
        } // Resolve target contract address if contract string is provided


        var target = schemaInstance.target,
            contract = schemaInstance.contract;
        if (!target && !contract) throw new Error('Schema must specify target address or contract');
        if (!target && !this._addresses[contract]) throw new Error("Can't find contract address for ".concat(contract)); // prettier-ignore

        schemaInstance.target = target || this._addresses[contract];
      }

      return schemaInstance;
    }
  }, {
    key: "_addSchemaToMulticall",
    value: function _addSchemaToMulticall(schemaInstance) {
      var _process;

      var id = schemaInstance.id,
          target = schemaInstance.target,
          call = schemaInstance.call,
          returns = schemaInstance.returns; // If schema already added but pending removal then cancel pending removal

      if (this._removeSchemaTimers[id]) {
        log2("Cancelled pending schema removal: ".concat(id));
        clearTimeout(this._removeSchemaTimers[id]);
        delete this._removeSchemaTimers[id];
        return;
      }

      this._totalActiveSchemas++;

      this._watcher.tap(function (calls) {
        return [].concat((0, _toConsumableArray2["default"])(calls), [{
          id: id,
          target: target,
          call: call,
          returns: returns
        }]);
      });

      log2("Schema added to multicall: ".concat(id));
      if ((_process = process) === null || _process === void 0 ? void 0 : _process.browser) log2('Active schemas (' + this._totalActiveSchemas + ' total):', this.activeSchemaIds);else log2("Active schemas (".concat(this._totalActiveSchemas, " total): ").concat(this.activeSchemaIds.join(','))); // prettier-ignore
    }
  }, {
    key: "_removeSchemaImmediately",
    value: function _removeSchemaImmediately(id) {
      if (this._removeSchemaTimers[id] !== undefined) delete this._removeSchemaTimers[id];
      log2("Schema removed from multicall: ".concat(id));

      this._watcher.tap(function (schemas) {
        return schemas.filter(function (_ref4) {
          var id_ = _ref4.id;
          return id_ !== id;
        });
      }); // If there are no active schemas unsubscribe from watcher updates


      if (--this._totalActiveSchemas === 0) {
        log2('No remaining active schemas');
        log2('Unsubscribed from watcher updates');

        this._watcherUpdates.unsub();

        this._watcherUpdates = null;
      } else {
        var _process2;

        if ((_process2 = process) === null || _process2 === void 0 ? void 0 : _process2.browser) log2('Active schemas (' + this._totalActiveSchemas + ' total):', this.activeSchemaIds);else log2("Active schemas (".concat(this._totalActiveSchemas, " remaining): ").concat(this.activeSchemaIds.join(','))); // prettier-ignore
      }
    }
  }, {
    key: "_removeSchemaFromMulticall",
    value: function _removeSchemaFromMulticall(id) {
      var _this5 = this;

      this._removeSchemaTimers[id] = setTimeout(function () {
        return _this5._removeSchemaImmediately(id);
      }, this._removeSchemaDelay);
    }
  }, {
    key: "_flushPendingSchemaRemovals",
    value: function _flushPendingSchemaRemovals() {
      var schemaTimers = Object.keys(this._removeSchemaTimers);
      if (schemaTimers.length === 0) return;
      log2("Flushing ".concat(schemaTimers.length, " pending schema removals"));

      for (var _i = 0, _schemaTimers = schemaTimers; _i < _schemaTimers.length; _i++) {
        var id = _schemaTimers[_i];
        log2("Forcing schema removal: ".concat(id));
        clearTimeout(this._removeSchemaTimers[id]);

        this._removeSchemaImmediately(id);
      }
    }
  }, {
    key: "_handleResult",
    value: function _handleResult(subject, obsPath, value) {
      var err = this._validateResult(subject, obsPath, value); // Trigger error on observable or emit result value to observable


      if (err) subject.error(err);else subject.next(value);
    }
  }, {
    key: "_validateResult",
    value: function _validateResult(subject, obsPath, value) {
      var _schemaDefinition$val3;

      var _obsPath$split = obsPath.split('.'),
          _obsPath$split2 = (0, _toArray2["default"])(_obsPath$split),
          observableKey = _obsPath$split2[0],
          args = _obsPath$split2.slice(1);

      var schemaDefinition = this._schemaByObservableKey[observableKey];
      var instancePath = "".concat(schemaDefinition.key).concat(args.length > 0 ? '.' : '').concat(args.join('.'));
      var schemaInstance = this._schemaInstances[instancePath]; // Pass validation if no validator found for this schema definition

      if (!((_schemaDefinition$val3 = schemaDefinition.validate) === null || _schemaDefinition$val3 === void 0 ? void 0 : _schemaDefinition$val3.hasOwnProperty(observableKey))) return;

      try {
        // Call validation func on schema definition for result value and pass schema instance args
        // as 2nd param and also this context
        var validate = schemaDefinition.validate[observableKey].call({
          args: schemaInstance.args
        }, value, schemaInstance.args);
        if (validate) throw new Error(validate);
        return; // Pass validation
      } catch (err) {
        log2('Validation error for ' + obsPath + ' result:', value);
        return err; // Fail validation
      }
    }
  }, {
    key: "_subscribeToWatcherUpdates",
    value: function _subscribeToWatcherUpdates() {
      var _this6 = this;

      log2('Subscribed to watcher updates');
      this._watcherUpdates = this._watcher.subscribe(function (update) {
        var subject = (0, _get["default"])(_this6._subjects, update.type);

        if (subject) {
          var _update$value;

          var logValue = ((_update$value = update.value) === null || _update$value === void 0 ? void 0 : _update$value._isBigNumber) ? "".concat(update.value.toString(), " (BigNumber)") : update.value;
          log2('Got watcher update for ' + update.type + ':', logValue);

          _this6._handleResult(subject, update.type, update.value);
        } else _this6._multicallResultCache[update.type] = update.value;
      });
    }
  }, {
    key: "observableKeys",
    get: function get() {
      return Object.keys(this._schemaByObservableKey);
    }
  }, {
    key: "watcher",
    get: function get() {
      return this._watcher;
    }
  }, {
    key: "activeSchemas",
    get: function get() {
      return this._watcher.schemas.filter(function (_ref5) {
        var id = _ref5.id;
        return id;
      }); // Filter only schemas with id
    }
  }, {
    key: "activeSchemaIds",
    get: function get() {
      return this.activeSchemas.map(function (_ref6) {
        var id = _ref6.id;
        return id;
      });
    }
  }, {
    key: "totalActiveSchemas",
    get: function get() {
      return this._totalActiveSchemas;
    }
  }, {
    key: "totalSchemaSubscribers",
    get: function get() {
      return this._totalSchemaSubscribers;
    }
  }]);
  return MulticallService;
}(_servicesCore.PublicService);

exports["default"] = MulticallService;